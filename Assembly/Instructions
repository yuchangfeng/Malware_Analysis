Table 4-1: Instruction Format
Mnemonic       Destination operand         Source operand
  mov                ecx                        0x42
  
  
  
Table 4-2: Instruction Opcodes
Instruction          mov ecx,                 0x42
Opcodes              B9 42                    42 00 00 00



Table 4-4: mov Instruction Examples
Instruction              Description
mov eax, ebx             Copies the contents of EBX into the EAX register Copies the value 0x42 into the EAX register
mov eax, 0x42            Copies the value 0x42 into the EAX register
mov eax, [0x4037C4]      Copies the 4 bytes at the memory location 0x4037C4 into the EAX register
mov eax, [ebx]           Copies the 4 bytes at the memory location specified by the EBX register into the EAX register
mov eax, [ebx+esi*4]     Copies the 4 bytes at the memory location specified by the result of the equation ebx+esi*4 into the EAX register



Arithmetic
Table 4-5: Addition and Subtraction Instruction Examples
Instruction            Description
sub eax, 0x10          Subtracts 0x10 from EAX
add eax, ebx           Adds EBX to EAX and stores the result in EAX
inc edx                Increments EDX by 1
dec ecx                Decrements ECX by 1


Table 4-6: Multiplication and Division Instruction Examples
Instruction        Description
mul 0x50           Multiplies EAX by 0x50 and stores the result in EDX:EAX
div 0x75           Divides EDX:EAX by 0x75 and stores the result in EAX and the remainder in EDX


Table 4-7: Common Logical and Shifting Arithmetic Instructions
 Instruction
xor eax, eax or eax, 0x7575
mov eax, 0xA shl eax, 2
mov bl, 0xA ror bl, 2
Description
Clears the EAX register
Performs the logical or operation on EAX with 0x7575
Shifts the EAX register to the left 2 bits; these two instructions result in EAX = 0x28, because 1010 (0xA in binary) shifted 2 bits left is 101000 (0x28)
Rotates the BL register to the right 2 bits; these two instructions result in BL = 10000010, because 1010 rotated 2 bits right is 10000010
 
 
 
 Table 4-8: cmp Instruction and Flags
 cmp dst, src       ZF     CF
  dst = src         1      0
  dst < src         0      1
  dst > src         0      0

Table 4-9: Conditional Jumps
 Instruction
  jz loc 
  jnz loc 
  je loc
  jne loc 
  jg loc 
  jge loc
  ja loc 
  jae loc 
  jl loc
  jle loc
  jb loc 
  jbe loc 
  jo loc
  js loc 
  jecxz loc
Description
Jump to specified location if ZF = 1. 
Jump to specified location if ZF = 0.
Same as jz, but commonly used after a cmp instruction. Jump will occur if the destination operand equals the source operand.
Same as jnz, but commonly used after a cmp. Jump will occur if the destination operand is not equal to the source operand.
Performs signed comparison jump after a cmp if the destination operand is greater than the source operand.
Performs signed comparison jump after a cmp if the destination operand is greater than or equal to the source operand.
Same as jg, but an unsigned comparison is performed. 
Same as jge, but an unsigned comparison is performed.
Performs signed comparison jump after a cmp if the destination operand is less than the source operand.
Performs signed comparison jump after a cmp if the destination operand is less than or equal to the source operand.
Same as jl, but an unsigned comparison is performed. 
Same as jle, but an unsigned comparison is performed. 
Jump if the previous instruction set the overflow flag (OF = 1). 
Jump if the sign flag is set (SF = 1).
Jump to location if ECX = 0.



Table 4-10: rep Instruction Termination Requirements
 Instruction
rep
repe, repz 
repne, repnz
Description
Repeat until ECX = 0
Repeat until ECX = 0 or ZF = 0 
Repeat until ECX = 0 or ZF = 1


Table 4-11: rep Instruction Examples
 Instruction
repe cmpsb
rep stosb
rep movsb
repne scasb
Description
Used to compare two data buffers. EDI and ESI must be set to the two buffer locations, and ECX must be set to the buffer length. The comparison will continue until ECX = 0 or the buffers are not equal.
Used to initialize all bytes of a buffer to a certain value. EDI will contain the buffer location, and AL must contain the initialization value. This instruction is often seen used with xor eax, eax.
Typically used to copy a buffer of bytes. ESI must be set to the source buffer address, EDI must be set to the destination buffer address, and ECX must contain the length to copy. Byte-by-byte copy will continue until ECX = 0.
Used for searching a data buffer for a single byte. EDI must contain the address of the buffer, AL must contain the byte you are looking for, and ECX must be set to the buffer length. The comparison will continue until ECX = 0 or until the byte is found.







 

  
